R_BASIC
================

## Basic of R

<hr>
본 정리는 부산대학교 통계프로그래밍 수업 자료를 참고하여 작성
되었습니다.
<hr>

### 1. 통계 프로그래밍 소개.

(mac) opt + cmd + i =\> make code chunk.

#### R Packages

``` r
#install.packages("combinat")
library(combinat)
```

    ## 
    ## Attaching package: 'combinat'

    ## The following object is masked from 'package:utils':
    ## 
    ##     combn

``` r
combinat::permn(1:3) # Package_name :: function_name(arg)
```

    ## [[1]]
    ## [1] 1 2 3
    ## 
    ## [[2]]
    ## [1] 1 3 2
    ## 
    ## [[3]]
    ## [1] 3 1 2
    ## 
    ## [[4]]
    ## [1] 3 2 1
    ## 
    ## [[5]]
    ## [1] 2 3 1
    ## 
    ## [[6]]
    ## [1] 2 1 3

#### Operator

1.  Binary Operator

``` r
23 + 15
```

    ## [1] 38

``` r
23 - 15
```

    ## [1] 8

``` r
23 * 15
```

    ## [1] 345

``` r
23 / 15
```

    ## [1] 1.533333

``` r
2^3 # Power
```

    ## [1] 8

``` r
4 %% 2 # modulus
```

    ## [1] 0

``` r
4 %/% 2 # integer division
```

    ## [1] 2

2.  Comparison operator

- 두 값을 비교하고 그 결과로 논리값인 참 또는 거짓 값을 반환..
- ==, !=, \>, \<, \>=, \<=

3.  Logical operator

- and, or 연산자 ㅇㅇ
- ~, &, \|

##### Object assgining

``` r
x1 = factorial(5)
x1
```

    ## [1] 120

``` r
x1 + 120 
```

    ## [1] 240

### 2. Data Types and Structures

#### Vector

- 벡터는 데이터 유형(숫자, 문자 등)이 **같은 요소**들의 나열이며 R에서
  가장 기본적이고 중요한 데이터 구조이다.

- 벡터는 다음의 함수로 생성할 수 있다.

<!-- -->

    c(arg1 , arg2...)

- 이외에도 여러가지 벡터가 생성되는 함수가 있다.

<!-- -->

    seq(...), rep(...), ...

``` r
c(1, 2, 5)
```

    ## [1] 1 2 5

``` r
c("A", "B", "C")
```

    ## [1] "A" "B" "C"

``` r
c(1, "A", 3) # A에 맞춰어 1, 3의 type이 문자열으로 변경됨.
```

    ## [1] "1" "A" "3"

``` r
example = c(1, "A", 3)
class(example[1])
```

    ## [1] "character"

``` r
seq(1, 10) # 1:10
```

    ##  [1]  1  2  3  4  5  6  7  8  9 10

``` r
seq(from = 1, to = 10)
```

    ##  [1]  1  2  3  4  5  6  7  8  9 10

``` r
seq(from = 1, to = 10, by = 3)
```

    ## [1]  1  4  7 10

``` r
seq(from = 1, to = 10, length.out = 3)
```

    ## [1]  1.0  5.5 10.0

``` r
rep(3, 10)
```

    ##  [1] 3 3 3 3 3 3 3 3 3 3

``` r
rep(3, times = 10)
```

    ##  [1] 3 3 3 3 3 3 3 3 3 3

``` r
rep(1:5, times = 3) # 1:5이 3번 반복
```

    ##  [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5

``` r
rep(1:5, each = 3) # 1:5 각각 3번씩 반복
```

    ##  [1] 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5

``` r
rep(1:5, times = c(1, 2, 3, 2, 1)) # element wise하게 반복
```

    ## [1] 1 2 2 3 3 3 4 4 5

``` r
x = 5 : 9
y = -2 : 2
c(x, y)
```

    ##  [1]  5  6  7  8  9 -2 -1  0  1  2

#### Indexing Vector

- 벡터 인덱싱은 벡터의 특정 요소에 접근하고 조작하는 방법을 나타낸다.

- **기본적으로 대괄호**를 사용하여 벡터의 특정 위치에 있는 요소에
  접근한다.

  1.  다중원소 : 쉼표를 사용하여 여러 요소에 접근한다.
  2.  조건부 : 논리벡터를 사용하여 특정 조건을 만족하는 요소에 접근한다.
  3.  이름 : 벡터의 원소에 이름을 부여하고 해당 이름을 사용하여 요소에
      접근한다.

- 이런 인덱싱을 갖는 벡터를 통해 특정원소를 수정할 수 있다.

``` r
x = seq(9, 100, by = 9)
x[1]
```

    ## [1] 9

``` r
x[3:5]
```

    ## [1] 27 36 45

``` r
x[5:3]
```

    ## [1] 45 36 27

``` r
x[-3] # 3번쨰 index 원소를 제외하고 
```

    ##  [1]  9 18 36 45 54 63 72 81 90 99

``` r
x[c(2, 4, 6, 8, 10)]
```

    ## [1] 18 36 54 72 90

``` r
x[-c(2, 4, 6, 8, 10)]
```

    ## [1]  9 27 45 63 81 99

``` r
# logical vector(조건부)
cond = x <= 50
cond
```

    ##  [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE

``` r
x[cond]
```

    ## [1]  9 18 27 36 45

``` r
letters[1:11]
```

    ##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k"

``` r
names(x) = letters[1:11]
x # x라는 벡터에 names()라는 함수를 이용해 이름을 붙혀줌.
```

    ##  a  b  c  d  e  f  g  h  i  j  k 
    ##  9 18 27 36 45 54 63 72 81 90 99

``` r
x["a"]
```

    ## a 
    ## 9

``` r
x[c("a", "b")]
```

    ##  a  b 
    ##  9 18

``` r
# x[-c("a", "b")] -> 이건 또 안되노..?
```

``` r
x[1]
```

    ## a 
    ## 9

``` r
x[1] = 100
x[1]
```

    ##   a 
    ## 100

#### Operations of Vectors

- 벡터 연산의 종류
  1.  요소별 연산(element-wise operations)

  - 두 벡터에 대한 연산으로 같은 위치에 있는 요소들끼리 연산이 수행된다.
  - 요소별 연산은 벡터의 길이를 고려하여야 하며 길이가 같은 경우에 같은
    위치의 원소별로 적용되고 다른 경우는 **반복**을 툥해 적용된다.

  2.  스킬라와의 연산

  - 스칼라는 단일 값, 즉 크기와 방향이 없는 값이며 예를 들어 3, TRUE
    등이다.
  - 벡터의 **모든 요소**에 스칼라 값을 더하거나 곱하는 등의 연산

``` r
x = c(10, 10 ,9)
y = c(80, 90, 70)
z = c(100, 90, 50)

x - 5 # operations with scalar
```

    ## [1] 5 5 4

``` r
y + z
```

    ## [1] 180 180 120

``` r
y * 0.4
```

    ## [1] 32 36 28

``` r
y * z
```

    ## [1] 8000 8100 3500

``` r
z^2
```

    ## [1] 10000  8100  2500

``` r
x^c(1, 2, 3) # element-wise하게 연산됨.
```

    ## [1]  10 100 729

#### Functions of Vector

- 함수 중 인자(arg)를 값이 아니라 **벡터**가 필요한 함수들을
  벡터함수라고 한다.

``` r
x = c(2, 3, 5, 7, 11)
sum(x)
```

    ## [1] 28

``` r
cumsum(x)
```

    ## [1]  2  5 10 17 28

``` r
prod(x)
```

    ## [1] 2310

``` r
cumprod(x)
```

    ## [1]    2    6   30  210 2310

``` r
mean(x)
```

    ## [1] 5.6

``` r
median(x)
```

    ## [1] 5

``` r
length(x)
```

    ## [1] 5

``` r
x = c(2, 6, 3, 4, 8, 6, 4, 6, 2, 1)
unique(x)
```

    ## [1] 2 6 3 4 8 1

``` r
sort(x)
```

    ##  [1] 1 2 2 3 4 4 6 6 6 8

``` r
rev(x)
```

    ##  [1] 1 2 6 4 6 8 4 3 6 2

``` r
# Exercise 2.1
x = seq(-4, 4, by = 0.1)
f_x = c((1 / sqrt(2 * pi)) * exp(-x^2 / 2))

x[which.max(f_x)]
```

    ## [1] 0

``` r
cond = x[x < 0]

f_x_2 = f_x = c((1 / sqrt(2 * pi)) * exp(-cond^2 / 2))
sum(f_x_2)
```

    ## [1] 4.800275

#### Missing Value

- 결측치 : 데이터 값이 존재하지 않는 산태를 의미하며 데이터가 수집되지
  않았거나 관측되지 않은 경우에 발생할 수 있다.

- R에서는 간단히 NA라는 값으로 표현한다.

- 결측치는 원활한 계산을 방해하기 때문에 결측치가 존재한다면 결측치의
  처리가 필수이다.

``` r
x = c(1, 2, NA, 4, NA, 6)
x
```

    ## [1]  1  2 NA  4 NA  6

``` r
sum(x)
```

    ## [1] NA

``` r
is.na(x)
```

    ## [1] FALSE FALSE  TRUE FALSE  TRUE FALSE

``` r
sum(!is.na(x))
```

    ## [1] 4

``` r
sum(x, na.rm = TRUE)
```

    ## [1] 13

``` r
x[is.na(x)] = 0
sum(x)
```

    ## [1] 13

#### Matrix

- 행렬은 데이터 유형(숫자, 문자 등)이 **같은 요소**들의 2차원 나열이며
  2차원으로 구성된 벡터로 볼 수 있다.

- 벡터와 같은 방식의 연산이 수행되며 행렬의 곱은 다음의 연산자를
  사용한다. \*\*%\*%\*\*

``` r
x = 1:12

matrix(data = x, nrow = 3 ,ncol = 4) # col을 기준으로 원소가 들어간다.
```

    ##      [,1] [,2] [,3] [,4]
    ## [1,]    1    4    7   10
    ## [2,]    2    5    8   11
    ## [3,]    3    6    9   12

``` r
matrix(data = x, nrow = 3) # row가 3이므로 자동으로 col은 4가 된다.
```

    ##      [,1] [,2] [,3] [,4]
    ## [1,]    1    4    7   10
    ## [2,]    2    5    8   11
    ## [3,]    3    6    9   12

``` r
matrix(data = x, nrow = 3, byrow = TRUE) # byrow == 행 기준으로 원소가 들어가게..
```

    ##      [,1] [,2] [,3] [,4]
    ## [1,]    1    2    3    4
    ## [2,]    5    6    7    8
    ## [3,]    9   10   11   12

``` r
m = matrix(data =x , ncol = 3, byrow = TRUE)
m[3, 1] # 3행 1열
```

    ## [1] 7

``` r
m[2, ]
```

    ## [1] 4 5 6

``` r
m[, c(1, 3)]
```

    ##      [,1] [,2]
    ## [1,]    1    3
    ## [2,]    4    6
    ## [3,]    7    9
    ## [4,]   10   12

``` r
m[7]
```

    ## [1] 8

``` r
as.vector(m) # 열을 뽑아서 벡터화..
```

    ##  [1]  1  4  7 10  2  5  8 11  3  6  9 12

``` r
m[m > 5]
```

    ## [1]  7 10  8 11  6  9 12

#### 백터를 사용한 행렬의 생성

- 행렬은 여러개의 벡터들을 사용한 생성이 가능하다.
- **벡터들은 길이가 모두 동일해야한다.**

#### Naming the Matrix

- 행렬은 `rownames()`, `colnames()`라는 함수로 각 행과 열에 이름을
  지정하는 것이 가능하다.

- 당연히 행렬 이외의 객체에도 naming이 가능하다. (ex.vector)

- 벡터와 마찬가지로 지정한 이름으로 인덱싱이 가능하다.

``` r
x = 1:5
y = c(2, 3, 5, 7, 11)
z = -2:2

rbind(x, y, z)
```

    ##   [,1] [,2] [,3] [,4] [,5]
    ## x    1    2    3    4    5
    ## y    2    3    5    7   11
    ## z   -2   -1    0    1    2

``` r
cbind(x, y, z)
```

    ##      x  y  z
    ## [1,] 1  2 -2
    ## [2,] 2  3 -1
    ## [3,] 3  5  0
    ## [4,] 4  7  1
    ## [5,] 5 11  2

``` r
rbind(x, prime = y, z) # name = data
```

    ##       [,1] [,2] [,3] [,4] [,5]
    ## x        1    2    3    4    5
    ## prime    2    3    5    7   11
    ## z       -2   -1    0    1    2

``` r
rbind(x, y, z, deparse.level = 0) # level = 0(=no names)
```

    ##      [,1] [,2] [,3] [,4] [,5]
    ## [1,]    1    2    3    4    5
    ## [2,]    2    3    5    7   11
    ## [3,]   -2   -1    0    1    2

``` r
rbind(x, y, z, deparse.level = 1) # level = 1(=objects names), default
```

    ##   [,1] [,2] [,3] [,4] [,5]
    ## x    1    2    3    4    5
    ## y    2    3    5    7   11
    ## z   -2   -1    0    1    2

``` r
rbind(1:5, c(2, 3, 5, 7, 11), -2:2, deparse.level = 1) # level = 1(=objects names | no names)
```

    ##      [,1] [,2] [,3] [,4] [,5]
    ## [1,]    1    2    3    4    5
    ## [2,]    2    3    5    7   11
    ## [3,]   -2   -1    0    1    2

``` r
rbind(x, y, z, deparse.level = 2) # level = 2(= must make names)
```

    ##   [,1] [,2] [,3] [,4] [,5]
    ## x    1    2    3    4    5
    ## y    2    3    5    7   11
    ## z   -2   -1    0    1    2

``` r
rbind(1:5, c(2, 3, 5, 7, 11), -2:2, deparse.level = 2)
```

    ##               [,1] [,2] [,3] [,4] [,5]
    ## 1:5              1    2    3    4    5
    ## c(2, 3, 5,...    2    3    5    7   11
    ## -2:2            -2   -1    0    1    2

``` r
m = matrix(1:6, nrow = 3)

x = c(2, 3, 5)
cbind(m, x, deparse.level = 0)
```

    ##      [,1] [,2] [,3]
    ## [1,]    1    4    2
    ## [2,]    2    5    3
    ## [3,]    3    6    5

``` r
cbind(m, x, m, deparse.level = 0)
```

    ##      [,1] [,2] [,3] [,4] [,5]
    ## [1,]    1    4    2    1    4
    ## [2,]    2    5    3    2    5
    ## [3,]    3    6    5    3    6

``` r
x = 1:10
m = matrix(data = x, ncol = 5)
rownames(m)
```

    ## NULL

``` r
colnames(m)
```

    ## NULL

``` r
rownames(m) = c("odd", "even")
colnames(m) = c("1st", "2nd", "3rd", "4th", "5th")
m
```

    ##      1st 2nd 3rd 4th 5th
    ## odd    1   3   5   7   9
    ## even   2   4   6   8  10

#### Functions of Matrix

``` r
m = matrix(data = c(2, 3,5, 7, 11, 13), 3)
?row()
row(m); col(m) # row() == 행 기준으로 index 출력 matrix 꼴로
```

    ##      [,1] [,2]
    ## [1,]    1    1
    ## [2,]    2    2
    ## [3,]    3    3

    ##      [,1] [,2]
    ## [1,]    1    2
    ## [2,]    1    2
    ## [3,]    1    2

``` r
row(m) <= col(m)
```

    ##       [,1]  [,2]
    ## [1,]  TRUE  TRUE
    ## [2,] FALSE  TRUE
    ## [3,] FALSE FALSE

``` r
m[row(m) <= col(m)]
```

    ## [1]  2  7 11

``` r
m[row(m) > col(m)] = 100
m
```

    ##      [,1] [,2]
    ## [1,]    2    7
    ## [2,]  100   11
    ## [3,]  100  100

``` r
nrow(m); ncol(m); dim(m)
```

    ## [1] 3

    ## [1] 2

    ## [1] 3 2

``` r
rowSums(m) # 행 하나 잡고 sum
```

    ## [1]   9 111 200

``` r
colMeans(m)
```

    ## [1] 67.33333 39.33333

``` r
# matrix cal functions
m = cbind(m, c(1, 2, 3))

solve(m) # inverse of m
```

    ##             [,1]        [,2]          [,3]
    ## [1,] -0.02123061  0.01004322  0.0003813883
    ## [2,] -0.01271294 -0.01195017  0.0122044241
    ## [3,]  1.13145182  0.06356471 -0.0861937452

``` r
t(m)
```

    ##      [,1] [,2] [,3]
    ## [1,]    2  100  100
    ## [2,]    7   11  100
    ## [3,]    1    2    3

``` r
b = c(2, 3, 1)
solve(m, b) # solves the equation of mx = b for x
```

    ## [1] -0.01195017 -0.04907196  2.36740402

``` r
diag(m)
```

    ## [1]  2 11  3

``` r
diag(3)
```

    ##      [,1] [,2] [,3]
    ## [1,]    1    0    0
    ## [2,]    0    1    0
    ## [3,]    0    0    1

``` r
diag(4, nrow = 2)
```

    ##      [,1] [,2]
    ## [1,]    4    0
    ## [2,]    0    4

- Array는 생략

#### Apply

- apply 함수는 행 또는 열에 **각각 벡터 함수**를 적용하고자 할 때
  사용된다.

- `apply(X, MARGIN, FUNC, ...)`

  1.  X : matrix, array, DataFrame 등 행과 열을 가진 객체
  2.  MARGIN : 함수를 적용할 방향, 1 = 행, 2 = 열
  3.  FUNC : 적용할 함수

``` r
m = matrix(c(9, 6, 2, 4, 3, 8, 5, 7, 1), 3)
apply(m, 1,sum) # rowSums(m)
```

    ## [1] 18 16 11

``` r
apply(m, 1, cumsum)
```

    ##      [,1] [,2] [,3]
    ## [1,]    9    6    2
    ## [2,]   13    9   10
    ## [3,]   18   16   11

``` r
apply(m, 1, function(xx) sum(xx[xx>=5]))
```

    ## [1] 14 13  8

### List

- list는 백터의 일반적인 형태이며 데이터 유형이나 길이가 같을 필요가
  없다.
- `apply()`와 비슷한 `lapply()`가 있다.

``` r
x = list(
  num = c(1, 2, 3),
  "ABCD",
  identity = diag(2)
)

x
```

    ## $num
    ## [1] 1 2 3
    ## 
    ## [[2]]
    ## [1] "ABCD"
    ## 
    ## $identity
    ##      [,1] [,2]
    ## [1,]    1    0
    ## [2,]    0    1

``` r
x[1] # 1층 
```

    ## $num
    ## [1] 1 2 3

``` r
x[[1]] # 1층의 values
```

    ## [1] 1 2 3

``` r
x$num
```

    ## [1] 1 2 3

``` r
x["num"]
```

    ## $num
    ## [1] 1 2 3

``` r
x[["num"]]
```

    ## [1] 1 2 3

``` r
x[3]
```

    ## $identity
    ##      [,1] [,2]
    ## [1,]    1    0
    ## [2,]    0    1

``` r
x[[3]]
```

    ##      [,1] [,2]
    ## [1,]    1    0
    ## [2,]    0    1

``` r
x[[3]][2, 1]
```

    ## [1] 0

``` r
A = list(X = seq(101, 55, -5), Y = seq(205, 299, 8))
A
```

    ## $X
    ##  [1] 101  96  91  86  81  76  71  66  61  56
    ## 
    ## $Y
    ##  [1] 205 213 221 229 237 245 253 261 269 277 285 293

``` r
lapply(A, sum)
```

    ## $X
    ## [1] 785
    ## 
    ## $Y
    ## [1] 2988

#### Factor

- Factor는 문자형 데이터의 특이한 형태이다.
- 문자형 데이터이면서 특정 요소들이 반복될 때 유용하다.
- 정해진 요소 외에는 입력이 불가능하다.
- 생물통계학 저장소의 lecture1.md를 참고하자.

``` r
x1 = gl(n = 3, k = 5, labels = c("A", "B", "C"))
#gl(n = 3, k = 5, labels = c("A", "B")) -> error
gl(n = 3, k = 5, labels = c("A", "B", "C", "D"))
```

    ##  [1] A A A A A B B B B B C C C C C
    ## Levels: A B C D

``` r
levels(x1)
```

    ## [1] "A" "B" "C"

``` r
table(x1)
```

    ## x1
    ## A B C 
    ## 5 5 5

``` r
x2 = rep(c("A", "B", "C"), each = 5)
x3 = factor(x2)
x3
```

    ##  [1] A A A A A B B B B B C C C C C
    ## Levels: A B C

#### Data Frame

- Matrix와 비슷한 구조이다.
- 열은 **하나의 데이터 유형**으로 이루어져 있다.
- 각 열들은 데이터의 유형이 다를 수 있다.
- `data.frame()`으로 생성할 수 있다.

``` r
data = data.frame(
  char_num = c("1", "2", "3", "4"),
  score = c(80, 90, 70, 60),
  grade = factor(c("A", "A", "B", "C"), levels = c("A", "B", "C", "F"))
)

# indexing 방법은 matrix나 list 등과 유사함..

row.names(data)
```

    ## [1] "1" "2" "3" "4"

``` r
row.names(data) = c("1st", "2nd", "3rd", "4th")
colnames(data)
```

    ## [1] "char_num" "score"    "grade"

``` r
colnames(data)[2]
```

    ## [1] "score"

``` r
colnames(data)[2] = "mid"
data
```

    ##     char_num mid grade
    ## 1st        1  80     A
    ## 2nd        2  90     A
    ## 3rd        3  70     B
    ## 4th        4  60     C
