R_BASIC
================

## Basic of R

<hr>
본 정리는 부산대학교 통계프로그래밍 수업 자료를 참고하여 작성
되었습니다.
<hr>

### 1. 통계 프로그래밍 소개.

(mac) opt + cmd + i =\> make code chunk.

#### R Packages

``` r
#install.packages("combinat")
library(combinat)
```

    ## 
    ## Attaching package: 'combinat'

    ## The following object is masked from 'package:utils':
    ## 
    ##     combn

``` r
combinat::permn(1:3) # Package_name :: function_name(arg)
```

    ## [[1]]
    ## [1] 1 2 3
    ## 
    ## [[2]]
    ## [1] 1 3 2
    ## 
    ## [[3]]
    ## [1] 3 1 2
    ## 
    ## [[4]]
    ## [1] 3 2 1
    ## 
    ## [[5]]
    ## [1] 2 3 1
    ## 
    ## [[6]]
    ## [1] 2 1 3

#### Operator

1.  Binary Operator

``` r
23 + 15
```

    ## [1] 38

``` r
23 - 15
```

    ## [1] 8

``` r
23 * 15
```

    ## [1] 345

``` r
23 / 15
```

    ## [1] 1.533333

``` r
2^3 # Power
```

    ## [1] 8

``` r
4 %% 2 # modulus
```

    ## [1] 0

``` r
4 %/% 2 # integer division
```

    ## [1] 2

2.  Comparison operator

- 두 값을 비교하고 그 결과로 논리값인 참 또는 거짓 값을 반환..
- ==, !=, \>, \<, \>=, \<=

3.  Logical operator

- and, or 연산자 ㅇㅇ
- ~, &, \|

##### Object assgining

``` r
x1 = factorial(5)
x1
```

    ## [1] 120

``` r
x1 + 120 
```

    ## [1] 240

### 2. Data Types and Structures

#### Vector

- 벡터는 데이터 유형(숫자, 문자 등)이 **같은 요소**들의 나열이며 R에서
  가장 기본적이고 중요한 데이터 구조이다.

- 벡터는 다음의 함수로 생성할 수 있다.

<!-- -->

    c(arg1 , arg2...)

- 이외에도 여러가지 벡터가 생성되는 함수가 있다.

<!-- -->

    seq(...), rep(...), ...

``` r
c(1, 2, 5)
```

    ## [1] 1 2 5

``` r
c("A", "B", "C")
```

    ## [1] "A" "B" "C"

``` r
c(1, "A", 3) # A에 맞춰어 1, 3의 type이 문자열으로 변경됨.
```

    ## [1] "1" "A" "3"

``` r
example = c(1, "A", 3)
class(example[1])
```

    ## [1] "character"

``` r
seq(1, 10) # 1:10
```

    ##  [1]  1  2  3  4  5  6  7  8  9 10

``` r
seq(from = 1, to = 10)
```

    ##  [1]  1  2  3  4  5  6  7  8  9 10

``` r
seq(from = 1, to = 10, by = 3)
```

    ## [1]  1  4  7 10

``` r
seq(from = 1, to = 10, length.out = 3)
```

    ## [1]  1.0  5.5 10.0

``` r
rep(3, 10)
```

    ##  [1] 3 3 3 3 3 3 3 3 3 3

``` r
rep(3, times = 10)
```

    ##  [1] 3 3 3 3 3 3 3 3 3 3

``` r
rep(1:5, times = 3) # 1:5이 3번 반복
```

    ##  [1] 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5

``` r
rep(1:5, each = 3) # 1:5 각각 3번씩 반복
```

    ##  [1] 1 1 1 2 2 2 3 3 3 4 4 4 5 5 5

``` r
rep(1:5, times = c(1, 2, 3, 2, 1)) # element wise하게 반복
```

    ## [1] 1 2 2 3 3 3 4 4 5

``` r
x = 5 : 9
y = -2 : 2
c(x, y)
```

    ##  [1]  5  6  7  8  9 -2 -1  0  1  2

#### Indexing Vector

- 벡터 인덱싱은 벡터의 특정 요소에 접근하고 조작하는 방법을 나타낸다.

- **기본적으로 대괄호**를 사용하여 벡터의 특정 위치에 있는 요소에
  접근한다.

  1.  다중원소 : 쉼표를 사용하여 여러 요소에 접근한다.
  2.  조건부 : 논리벡터를 사용하여 특정 조건을 만족하는 요소에 접근한다.
  3.  이름 : 벡터의 원소에 이름을 부여하고 해당 이름을 사용하여 요소에
      접근한다.

- 이런 인덱싱을 갖는 벡터를 통해 특정원소를 수정할 수 있다.

``` r
x = seq(9, 100, by = 9)
x[1]
```

    ## [1] 9

``` r
x[3:5]
```

    ## [1] 27 36 45

``` r
x[5:3]
```

    ## [1] 45 36 27

``` r
x[-3] # 3번쨰 index 원소를 제외하고 
```

    ##  [1]  9 18 36 45 54 63 72 81 90 99

``` r
x[c(2, 4, 6, 8, 10)]
```

    ## [1] 18 36 54 72 90

``` r
x[-c(2, 4, 6, 8, 10)]
```

    ## [1]  9 27 45 63 81 99

``` r
# logical vector(조건부)
cond = x <= 50
cond
```

    ##  [1]  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE

``` r
x[cond]
```

    ## [1]  9 18 27 36 45

``` r
letters[1:11]
```

    ##  [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k"

``` r
names(x) = letters[1:11]
x # x라는 벡터에 names()라는 함수를 이용해 이름을 붙혀줌.
```

    ##  a  b  c  d  e  f  g  h  i  j  k 
    ##  9 18 27 36 45 54 63 72 81 90 99

``` r
x["a"]
```

    ## a 
    ## 9

``` r
x[c("a", "b")]
```

    ##  a  b 
    ##  9 18

``` r
# x[-c("a", "b")] -> 이건 또 안되노..?
```

``` r
x[1]
```

    ## a 
    ## 9

``` r
x[1] = 100
x[1]
```

    ##   a 
    ## 100

#### Operations of Vectors

- 벡터 연산의 종류
  1.  요소별 연산(element-wise operations)

  - 두 벡터에 대한 연산으로 같은 위치에 있는 요소들끼리 연산이 수행된다.
  - 요소별 연산은 벡터의 길이를 고려하여야 하며 길이가 같은 경우에 같은
    위치의 원소별로 적용되고 다른 경우는 **반복**을 툥해 적용된다.

  2.  스킬라와의 연산

  - 스칼라는 단일 값, 즉 크기와 방향이 없는 값이며 예를 들어 3, TRUE
    등이다.
  - 벡터의 **모든 요소**에 스칼라 값을 더하거나 곱하는 등의 연산

``` r
x = c(10, 10 ,9)
y = c(80, 90, 70)
z = c(100, 90, 50)

x - 5 # operations with scalar
```

    ## [1] 5 5 4

``` r
y + z
```

    ## [1] 180 180 120

``` r
y * 0.4
```

    ## [1] 32 36 28

``` r
y * z
```

    ## [1] 8000 8100 3500

``` r
z^2
```

    ## [1] 10000  8100  2500

``` r
x^c(1, 2, 3) # element-wise하게 연산됨.
```

    ## [1]  10 100 729

#### Functions of Vector

- 함수 중 인자(arg)를 값이 아니라 **벡터**가 필요한 함수들을
  벡터함수라고 한다.

``` r
x = c(2, 3, 5, 7, 11)
sum(x)
```

    ## [1] 28

``` r
cumsum(x)
```

    ## [1]  2  5 10 17 28

``` r
prod(x)
```

    ## [1] 2310

``` r
cumprod(x)
```

    ## [1]    2    6   30  210 2310

``` r
mean(x)
```

    ## [1] 5.6

``` r
median(x)
```

    ## [1] 5

``` r
length(x)
```

    ## [1] 5

``` r
x = c(2, 6, 3, 4, 8, 6, 4, 6, 2, 1)
unique(x)
```

    ## [1] 2 6 3 4 8 1

``` r
sort(x)
```

    ##  [1] 1 2 2 3 4 4 6 6 6 8

``` r
rev(x)
```

    ##  [1] 1 2 6 4 6 8 4 3 6 2

``` r
# Exercise 2.1
x = seq(-4, 4, by = 0.1)
f_x = c((1 / sqrt(2 * pi)) * exp(-x^2 / 2))

x[which.max(f_x)]
```

    ## [1] 0

``` r
cond = x[x < 0]

f_x_2 = f_x = c((1 / sqrt(2 * pi)) * exp(-cond^2 / 2))
sum(f_x_2)
```

    ## [1] 4.800275

#### Missing Value

- 결측치 : 데이터 값이 존재하지 않는 산태를 의미하며 데이터가 수집되지
  않았거나 관측되지 않은 경우에 발생할 수 있다.

- R에서는 간단히 NA라는 값으로 표현한다.

- 결측치는 원활한 계산을 방해하기 때문에 결측치가 존재한다면 결측치의
  처리가 필수이다.

``` r
x = c(1, 2, NA, 4, NA, 6)
x
```

    ## [1]  1  2 NA  4 NA  6

``` r
sum(x)
```

    ## [1] NA

``` r
is.na(x)
```

    ## [1] FALSE FALSE  TRUE FALSE  TRUE FALSE

``` r
sum(!is.na(x))
```

    ## [1] 4

``` r
sum(x, na.rm = TRUE)
```

    ## [1] 13

``` r
x[is.na(x)] = 0
sum(x)
```

    ## [1] 13
