---
title: "R_BASIC"
output: rmarkdown::github_document
---


## Basic of R

<hr>
본 정리는 부산대학교 통계프로그래밍 수업 자료를 참고하여 작성 되었습니다.
<hr>

### 1. 통계 프로그래밍 소개.

(mac) opt + cmd + i => make code chunk.

#### R Packages

```{r}
#install.packages("combinat")
library(combinat)
combinat::permn(1:3) # Package_name :: function_name(arg)
```


#### Operator

1. Binary Operator 

```{r}
23 + 15
23 - 15
23 * 15
23 / 15

2^3 # Power
4 %% 2 # modulus
4 %/% 2 # integer division

```

2. Comparison operator

* 두 값을 비교하고 그 결과로 논리값인 참 또는 거짓 값을 반환..
*  ==, !=, >, <, >=, <=

3. Logical operator

* and, or 연산자 ㅇㅇ
* ~, &, |

##### Object assgining

```{r}
x1 = factorial(5)
x1

x1 + 120 
```


### 2. Data Types and Structures

#### Vector

* 벡터는 데이터 유형(숫자, 문자 등)이 **같은 요소**들의 나열이며 R에서 가장 기본적이고 중요한 데이터 구조이다.

* 벡터는 다음의 함수로 생성할 수 있다.

```
c(arg1 , arg2...)
```

* 이외에도 여러가지 벡터가 생성되는 함수가 있다.

```
seq(...), rep(...), ...
```

```{r}
c(1, 2, 5)
c("A", "B", "C")
c(1, "A", 3) # A에 맞춰어 1, 3의 type이 문자열으로 변경됨.
```

```{r}
example = c(1, "A", 3)
class(example[1])
```

```{r}
seq(1, 10) # 1:10
seq(from = 1, to = 10)
seq(from = 1, to = 10, by = 3)
seq(from = 1, to = 10, length.out = 3)
```

```{r}
rep(3, 10)
rep(3, times = 10)
rep(1:5, times = 3) # 1:5이 3번 반복
rep(1:5, each = 3) # 1:5 각각 3번씩 반복
rep(1:5, times = c(1, 2, 3, 2, 1)) # element wise하게 반복
```

```{r}
x = 5 : 9
y = -2 : 2
c(x, y)
```

#### Indexing Vector

* 벡터 인덱싱은 벡터의 특정 요소에 접근하고 조작하는 방법을 나타낸다.

* **기본적으로 대괄호**를 사용하여 벡터의 특정 위치에 있는 요소에 접근한다. 
  1. 다중원소 : 쉼표를 사용하여 여러 요소에 접근한다.
  2. 조건부 : 논리벡터를 사용하여 특정 조건을 만족하는 요소에 접근한다.
  3. 이름 : 벡터의 원소에 이름을 부여하고 해당 이름을 사용하여 요소에 접근한다.
  
* 이런 인덱싱을 갖는 벡터를 통해 특정원소를 수정할 수 있다.

```{r}
x = seq(9, 100, by = 9)
x[1]
x[3:5]
x[5:3]
x[-3] # 3번쨰 index 원소를 제외하고 
x[c(2, 4, 6, 8, 10)]
x[-c(2, 4, 6, 8, 10)]
```

```{r}
# logical vector(조건부)
cond = x <= 50
cond
x[cond]
```

```{r}
letters[1:11]
names(x) = letters[1:11]
x # x라는 벡터에 names()라는 함수를 이용해 이름을 붙혀줌.
x["a"]
x[c("a", "b")]
# x[-c("a", "b")] -> 이건 또 안되노..?
```

```{r}
x[1]
x[1] = 100
x[1]
```


#### Operations of Vectors

* 벡터 연산의 종류
  1. 요소별 연산(element-wise operations)
    * 두 벡터에 대한 연산으로 같은 위치에 있는 요소들끼리 연산이 수행된다.
    * 요소별 연산은 벡터의 길이를 고려하여야 하며 길이가 같은 경우에 같은 위치의 원소별로 적용되고 다른 경우는 **반복**을 툥해 적용된다.
  2. 스킬라와의 연산
    * 스칼라는 단일 값, 즉 크기와 방향이 없는 값이며 예를 들어 3, TRUE 등이다.
    * 벡터의 **모든 요소**에 스칼라 값을 더하거나 곱하는 등의 연산

```{r}
x = c(10, 10 ,9)
y = c(80, 90, 70)
z = c(100, 90, 50)

x - 5 # operations with scalar
y + z
y * 0.4
y * z
z^2

x^c(1, 2, 3) # element-wise하게 연산됨.
```


#### Functions of Vector

* 함수 중 인자(arg)를 값이 아니라 **벡터**가 필요한 함수들을 벡터함수라고 한다.

```{r}
x = c(2, 3, 5, 7, 11)
sum(x)
cumsum(x)
prod(x)
cumprod(x)
mean(x)
median(x)
length(x)
```


```{r}
x = c(2, 6, 3, 4, 8, 6, 4, 6, 2, 1)
unique(x)
sort(x)
rev(x)
```


```{r}
# Exercise 2.1
x = seq(-4, 4, by = 0.1)
f_x = c((1 / sqrt(2 * pi)) * exp(-x^2 / 2))

x[which.max(f_x)]

cond = x[x < 0]

f_x_2 = f_x = c((1 / sqrt(2 * pi)) * exp(-cond^2 / 2))
sum(f_x_2)
```


#### Missing Value

* 결측치 : 데이터 값이 존재하지 않는 산태를 의미하며 데이터가 수집되지 않았거나 관측되지 않은 경우에 발생할 수 있다.

* R에서는 간단히 NA라는 값으로 표현한다.

* 결측치는 원활한 계산을 방해하기 때문에 결측치가 존재한다면 결측치의 처리가 필수이다.

```{r}
x = c(1, 2, NA, 4, NA, 6)
x
sum(x)
```

```{r}
is.na(x)
sum(!is.na(x))
sum(x, na.rm = TRUE)
```

```{r}
x[is.na(x)] = 0
sum(x)
```
















































































